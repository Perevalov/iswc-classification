{
    "http://en.wikipedia.org/wiki/Block_size_(cryptography)": {
        "http://xmlns.com/foaf/0.1/primaryTopic": [
            {
                "type": "uri",
                "value": "http://dbpedia.org/resource/Block_size_(cryptography)"
            }
        ]
    },
    "http://dbpedia.org/resource/Block_size_(cryptography)": {
        "http://www.w3.org/2000/01/rdf-schema#label": [
            {
                "type": "literal",
                "value": "Dimensione del blocco",
                "lang": "it"
            },
            {
                "type": "literal",
                "value": "Taille de bloc (cryptographie)",
                "lang": "fr"
            },
            {
                "type": "literal",
                "value": "Block size (cryptography)",
                "lang": "en"
            }
        ],
        "http://www.w3.org/2000/01/rdf-schema#comment": [
            {
                "type": "literal",
                "value": "In modern cryptography, symmetric key ciphers are generally divided into stream ciphers and block ciphers. Block ciphers operate on a fixed length string of bits. The length of this bit string is the block size. Both the input (plaintext) and output (ciphertext) are the same length; the output cannot be shorter than the input \u2014 this follows logically from the Pigeonhole principle and the fact that the cipher must be reversible \u2014 and it is undesirable for the output to be longer than the input. Joan Daemen's 3-Way and BaseKing have unusual block sizes of 96 and 192 bits, respectively.",
                "lang": "en"
            },
            {
                "type": "literal",
                "value": "Nella moderna crittografia, gli algoritmi a chiave simmetrica vengono usualmente divisi in due famiglie. La famiglia degli algoritmi a blocchi e la famiglia degli algoritmi a stream. Gli algoritmi a blocchi lavorano su un insieme di simboli per volta e li cifrano o decifrano tutti in parallelo. Il primo requisito di un algoritmo di questo tipo \u00e8 che il blocco di partenza e il blocco d'arrivo sia della stessa dimensione e il secondo requisito \u00e8 che la funzione utilizzata per cifrare sia invertibile sempre, altrimenti, alcune volte, pur avendo la chiave corretta, la procedura di decifrazione potrebbe non svolgersi correttamente.",
                "lang": "it"
            },
            {
                "type": "literal",
                "value": "En cryptologie moderne, la cryptographie sym\u00e9trique se divise en deux cat\u00e9gories : le chiffrement par bloc et le chiffrement par flot. Les chiffrements par bloc travaillent sur des blocs de bits dont la longueur est fixe. La taille de bloc se r\u00e9f\u00e8re au nombre de bits pr\u00e9sents dans le bloc trait\u00e9 par l'algorithme. Le bloc en clair est transmis \u00e0 l'algorithme de chiffrement qui va produire un bloc de m\u00eame taille mais chiffr\u00e9. La sortie ne peut pas \u00eatre plus courte que l'entr\u00e9e puisque le syst\u00e8me doit \u00eatre invers\u00e9 lors du d\u00e9chiffrement (contrairement aux fonctions de hachage).",
                "lang": "fr"
            }
        ],
        "http://www.w3.org/2002/07/owl#sameAs": [
            {
                "type": "uri",
                "value": "http://www.wikidata.org/entity/Q1053357"
            },
            {
                "type": "uri",
                "value": "http://dbpedia.org/resource/Block_size_(cryptography)"
            },
            {
                "type": "uri",
                "value": "http://fr.dbpedia.org/resource/Taille_de_bloc_(cryptographie)"
            },
            {
                "type": "uri",
                "value": "http://it.dbpedia.org/resource/Dimensione_del_blocco"
            },
            {
                "type": "uri",
                "value": "http://wikidata.dbpedia.org/resource/Q1053357"
            },
            {
                "type": "uri",
                "value": "http://rdf.freebase.com/ns/m.01qznw"
            }
        ],
        "http://purl.org/dc/terms/subject": [
            {
                "type": "uri",
                "value": "http://dbpedia.org/resource/Category:Symmetric-key_cryptography"
            }
        ],
        "http://xmlns.com/foaf/0.1/isPrimaryTopicOf": [
            {
                "type": "uri",
                "value": "http://en.wikipedia.org/wiki/Block_size_(cryptography)"
            }
        ],
        "http://www.w3.org/ns/prov#wasDerivedFrom": [
            {
                "type": "uri",
                "value": "http://en.wikipedia.org/wiki/Block_size_(cryptography)?oldid=713658303"
            }
        ],
        "http://dbpedia.org/ontology/abstract": [
            {
                "type": "literal",
                "value": "In modern cryptography, symmetric key ciphers are generally divided into stream ciphers and block ciphers. Block ciphers operate on a fixed length string of bits. The length of this bit string is the block size. Both the input (plaintext) and output (ciphertext) are the same length; the output cannot be shorter than the input \u2014 this follows logically from the Pigeonhole principle and the fact that the cipher must be reversible \u2014 and it is undesirable for the output to be longer than the input. Until the announcement of NIST's AES contest, the majority of block ciphers followed the example of the DES in using a block size of 64 bits (8 bytes). However the Birthday paradox tells us that after accumulating a number of blocks equal to the square root of the total number possible, there will be an approximately 50% chance of two or more being the same, which would start to leak information about the message contents. Thus even when used with a proper encryption mode (e.g. CBC or OFB), only 232 x 8 B = 32 GB of data can be safely sent under one key. In practice a greater margin of security is desired, restricting a single key to the encryption of much less data - say a few hundred megabytes. Once that seemed like a fair amount of data, but today it is easily exceeded. If the cipher mode does not properly randomise the input, the limit is even lower. Consequently, AES candidates were required to support a block length of 128 bits (16 bytes). This should be acceptable for up to 264 x 16 B = 256 Exabytes of data, and should suffice for quite a few years to come. The winner of the AES contest, Rijndael, supports block and key sizes of 128, 192, and 256 bits, but in AES the block size is always 128 bits. The extra block sizes were not adopted by the AES standard. Many block ciphers, such as RC5, support a variable block size. The Luby-Rackoff construction and the Outerbridge construction can both increase the effective block size of a cipher. Joan Daemen's 3-Way and BaseKing have unusual block sizes of 96 and 192 bits, respectively.",
                "lang": "en"
            },
            {
                "type": "literal",
                "value": "En cryptologie moderne, la cryptographie sym\u00e9trique se divise en deux cat\u00e9gories : le chiffrement par bloc et le chiffrement par flot. Les chiffrements par bloc travaillent sur des blocs de bits dont la longueur est fixe. La taille de bloc se r\u00e9f\u00e8re au nombre de bits pr\u00e9sents dans le bloc trait\u00e9 par l'algorithme. Le bloc en clair est transmis \u00e0 l'algorithme de chiffrement qui va produire un bloc de m\u00eame taille mais chiffr\u00e9. La sortie ne peut pas \u00eatre plus courte que l'entr\u00e9e puisque le syst\u00e8me doit \u00eatre invers\u00e9 lors du d\u00e9chiffrement (contrairement aux fonctions de hachage). Jusqu'au concours AES, la majorit\u00e9 des chiffrements par bloc utilisaient un bloc de 64 bits (8 octets). Cependant, en accord avec le paradoxe des anniversaires, les risques de collisions devenaient trop grands (il faut 232 blocs distincts pour trouver une collision avec une chance sur deux, ce qui est une porte ouverte pour diverses attaques). Avec un mode op\u00e9ratoire appropri\u00e9, 32 gigaoctets de donn\u00e9es peuvent \u00eatre transmis avec la m\u00eame cl\u00e9 avant de trouver une collision. Si \u00e0 l'\u00e9poque ce volume paraissait inaccessible, il est d\u00e9sormais tout \u00e0 fait envisageable. Si le mode op\u00e9ratoire est vuln\u00e9rable (mauvais al\u00e9a), la taille des donn\u00e9es n\u00e9cessaire peut diminuer. Pour ces raisons, le standard AES est bas\u00e9 sur un bloc de 128 bits (16 bytes). Les collisions se montent maintenant \u00e0 264 blocs distincts, soit 256 exaoctets, une valeur qui devrait \u00eatre suffisante pour la p\u00e9riode durant laquelle AES est suppos\u00e9 \u00eatre s\u00fbr (jusqu'aux environs de 2050). Le gagnant, Rijndael, supporte des blocs de 128, 192 et 256 bits mais le standard porte sur le bloc de 128 bits. D'autres chiffrements acceptent des blocs de taille variable. La construction de Luby-Rackoff et la construction d'Outerbridge peuvent toutes deux augmenter la robustesse effective d'un algorithme. Le chiffrement de Joan Daemen, 3-Way, a une taille inhabituelle de 96 bits. Citons encore Triple DES avec sa cl\u00e9 de 168 bits (112 bits effectifs), en r\u00e9alit\u00e9 192 bits mais les 24 bits suppl\u00e9mentaires ne sont utilis\u00e9s que pour un contr\u00f4le de parit\u00e9. \n* Portail de la cryptologie Portail de la cryptologie",
                "lang": "fr"
            },
            {
                "type": "literal",
                "value": "Nella moderna crittografia, gli algoritmi a chiave simmetrica vengono usualmente divisi in due famiglie. La famiglia degli algoritmi a blocchi e la famiglia degli algoritmi a stream. Gli algoritmi a blocchi lavorano su un insieme di simboli per volta e li cifrano o decifrano tutti in parallelo. Il primo requisito di un algoritmo di questo tipo \u00e8 che il blocco di partenza e il blocco d'arrivo sia della stessa dimensione e il secondo requisito \u00e8 che la funzione utilizzata per cifrare sia invertibile sempre, altrimenti, alcune volte, pur avendo la chiave corretta, la procedura di decifrazione potrebbe non svolgersi correttamente. Prima che il NIST annunciasse il concorso per la definizione del'AES la maggior parte degli algoritmi di cifrazione a blocchi utilizzavano blocchi di 64 bit come il DES. Il paradosso del compleanno enuncia che se si riesce ad accumulare un numero di dati cifrati uguali alla radice quadrata del numero totale di combinazioni dei dati cifrabili si ha una probabilit\u00e0 del 50% che due o pi\u00f9 blocchi si ripetano e questi possono essere utilizzati per forzare l'algoritmo. Il numero totale di combinazioni per un algoritmo con blocchi di 64 bit (8 byte) \u00e8 di B = 32 GB. Questo numero teorico va ridotto molto dato che si desidera rimanere molto sotto il 50% di probabilit\u00e0 e, quindi, i dati cifrabili con sicurezza sono poche centinaia di Megabyte. Una volta questo numero era considerato enorme e, quindi, sufficiente per tutte le necessit\u00e0, ma nella nostra epoca \u00e8 troppo piccolo e limitante considerando che, se l'algoritmo non gestisce adeguatamente i dati di ingresso sparpagliando i simboli pi\u00f9 frequenti, la probabilit\u00e0 di cadere nel paradosso del compleanno aumenta notevolmente. Di conseguenza, i candidati a diventare l'AES dovevano trattare blocchi a 128 bit (16 byte). Questo blocco produce B = 256 Exabyte di dati, un numero di dati sufficiente per i prossimi decenni. Alcuni cifrari come l'RC5 gestiscono lunghezze di blocco variabile mentre il cifrario di Joan Daemen, il 3-Way ha blocchi di 96 bit. La costruzione di Luby-Rackoff e la costruzione di Richard Outerbridge riescono ad aumentare la dimensione dei blocchi cifrati riducendo il problema derivato dal paradosso dei compleanni.",
                "lang": "it"
            }
        ],
        "http://dbpedia.org/ontology/wikiPageRevisionID": [
            {
                "type": "literal",
                "value": 713658303,
                "datatype": "http://www.w3.org/2001/XMLSchema#integer"
            }
        ],
        "http://dbpedia.org/ontology/wikiPageID": [
            {
                "type": "literal",
                "value": 294065,
                "datatype": "http://www.w3.org/2001/XMLSchema#integer"
            }
        ]
    },
    "http://dbpedia.org/resource/Block_size": {
        "http://dbpedia.org/ontology/wikiPageDisambiguates": [
            {
                "type": "uri",
                "value": "http://dbpedia.org/resource/Block_size_(cryptography)"
            }
        ]
    }
}